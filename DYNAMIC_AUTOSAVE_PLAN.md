# План реализации динамического автосохранения анкет

## Дата: 20.09.2025

## Цель
Реализовать динамическое автосохранение анкет после 100% заполнения активных вопросов, с учетом того, что количество вопросов может меняться.

## Текущая ситуация
- Автосохранение привязано к фиксированному числу вопросов
- Если количество активных вопросов изменится в БД, логика может работать некорректно
- Нет синхронизации между БД и ботом в реальном времени

## Предлагаемые изменения

### 1. Динамическая проверка количества вопросов

#### Метод `get_total_questions()` (уже существует, строки 94-101)
```python
def get_total_questions(self) -> int:
    """Получить общее количество активных вопросов"""
    try:
        questions = get_interview_questions()  # уже возвращает is_active=1
        return len(questions)
    except Exception as e:
        logger.error(f"Ошибка подсчета вопросов: {e}")
        return 0  # без фолбэка на 24, чтобы избежать рассинхрона
```

### 2. Обновление логики в `handle_message()` (строки 688-698)

**Текущий код:**
```python
# Переходим к следующему вопросу или автоматически сохраняем анкету
if current_question < session['total_questions']:
    await self.show_question_navigation(update, context, current_question + 1)
else:
    # Автоматически сохраняем анкету после последнего вопроса
    anketa_id = await self.auto_save_anketa(update, context, user_id)
```

**Новый код:**
```python
# Актуализируем количество вопросов перед проверкой
actual_total_questions = self.get_total_questions()
session['total_questions'] = actual_total_questions  # Обновляем в сессии

# Проверяем, ответил ли пользователь на все активные вопросы
if current_question < actual_total_questions:
    await self.show_question_navigation(update, context, current_question + 1)
else:
    # Автоматически сохраняем анкету после последнего активного вопроса
    logger.info(f"Пользователь {user_id} ответил на все {actual_total_questions} активных вопросов")
    anketa_id = await self.auto_save_anketa(update, context, user_id)
    if anketa_id:
        await self.show_completion_screen(update, context, anketa_id)
    else:
        # Если не удалось сохранить, показываем экран проверки
        await self.show_review_screen(update, context)
```

### 3. Обновление в `show_question_navigation()` (строка 306)

**Уже реализовано:**
```python
# Актуализируем количество вопросов (на случай динамических изменений)
session['total_questions'] = self.get_total_questions()
```
✅ Эта часть уже корректно реализована!

### 4. Добавить логирование для отладки

В метод `auto_save_anketa()` добавить:
```python
logger.info(f"Автосохранение: пользователь {user_id} заполнил {len(session['answers'])} из {session['total_questions']} вопросов")
```

## Преимущества решения

1. **Гибкость** - автоматически адаптируется к изменению количества вопросов
2. **Надежность** - всегда проверяет актуальное состояние БД
3. **Простота** - минимальные изменения в существующем коде
4. **Совместимость** - сохраняет текущую логику работы

## Потенциальные сценарии

### Сценарий 1: Уменьшение количества вопросов
- Было 14 вопросов, стало 10
- Пользователь на 11 вопросе
- Система определит, что он уже ответил на все активные (10)
- Анкета автоматически сохранится

### Сценарий 2: Увеличение количества вопросов
- Было 14 вопросов, стало 20
- Пользователь на 14 вопросе
- Система покажет 15-й вопрос
- Анкета сохранится после 20-го вопроса

### Сценарий 3: Деактивация вопросов в процессе
- Пользователь начал с 14 вопросами
- После 10-го вопроса деактивировали 2 вопроса (осталось 12)
- После 12-го вопроса анкета автоматически сохранится

## Дополнительные улучшения (опционально)

### 1. Кеширование с TTL
```python
class GrantServiceBotWithMenu:
    def __init__(self):
        self._questions_cache = None
        self._cache_timestamp = None
        self._cache_ttl = 60  # секунд
    
    def get_total_questions(self) -> int:
        if self._questions_cache and (time.time() - self._cache_timestamp < self._cache_ttl):
            return len(self._questions_cache)
        # Обновляем кеш
        self._questions_cache = get_interview_questions()
        self._cache_timestamp = time.time()
        return len(self._questions_cache)
```

### 2. Уведомление об изменениях
Если количество вопросов изменилось во время заполнения:
```python
if old_total != new_total:
    await update.message.reply_text(
        f"ℹ️ Количество вопросов изменилось: {old_total} → {new_total}"
    )
```

### 3. Метрики в БД
Сохранять в anketa_id информацию о версии вопросника:
- Количество активных вопросов на момент начала
- Количество активных вопросов на момент завершения
- Список ID отвеченных вопросов

## Тестирование

### Тест 1: Базовый сценарий
1. Запустить бота с 14 вопросами
2. Заполнить все 14 вопросов
3. Проверить автосохранение

### Тест 2: Деактивация вопросов
1. Начать заполнение с 14 вопросами
2. После 10-го вопроса деактивировать 2 вопроса в БД
3. Проверить, что анкета сохранится после 12-го вопроса

### Тест 3: Активация новых вопросов
1. Начать с 10 вопросами
2. После 5-го вопроса добавить еще 5 вопросов
3. Проверить, что бот покажет все 15 вопросов

### Тест 4: Полная деактивация
1. Начать с 10 вопросами
2. После 8-го вопроса деактивировать все оставшиеся
3. Проверить корректное поведение

## Риски и митигация

| Риск | Вероятность | Воздействие | Митигация |
|------|-------------|-------------|-----------|
| Частые изменения вопросов | Низкая | Среднее | Кеширование с TTL |
| Несинхронизация БД и бота | Низкая | Высокое | Проверка при каждом вопросе |
| Потеря данных при сбое | Низкая | Высокое | Промежуточное сохранение |
| Путаница у пользователей | Средняя | Низкое | Уведомления об изменениях |

## Заключение

Предлагаемое решение минимально изменяет существующий код, но делает систему значительно более гибкой и надежной. Основное изменение - добавление динамической проверки количества активных вопросов перед принятием решения об автосохранении.

Это позволит администраторам свободно управлять вопросами в БД, не беспокоясь о том, что бот будет работать некорректно.