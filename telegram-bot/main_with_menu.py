#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
–ì—Ä–∞–Ω—Ç–°–µ—Ä–≤–∏—Å - Telegram Bot —Å –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–º –º–µ–Ω—é
–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: Telegram Bot + n8n + –ì–∏–≥–∞–ß–∞—Ç API
–ú–µ–Ω—é: –ì–ª–∞–≤–Ω–æ–µ ‚Üí –ù–∞–≤–∏–≥–∞—Ü–∏—è ‚Üí –ü—Ä–æ–≤–µ—Ä–∫–∞
"""

import logging
import os
import sys
from typing import Dict, Any, Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, 
    CommandHandler, 
    MessageHandler, 
    CallbackQueryHandler,
    ContextTypes,
    filters
)
import requests
import json
from datetime import datetime

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ –º–æ–¥—É–ª—é –ë–î
sys.path.append('/var/GrantService/data')
from database import db

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler('/var/GrantService/logs/telegram_bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class GrantServiceBotWithMenu:
    def __init__(self):
        self.token = os.getenv('TELEGRAM_BOT_TOKEN')
        self.n8n_webhook_url = os.getenv('N8N_WEBHOOK_URL', 'http://localhost:5678/webhook/grant-service')
        self.gigachat_api_key = os.getenv('GIGACHAT_API_KEY')
        
        # –°–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        self.user_sessions = {}
        
        # –°–æ—Å—Ç–æ—è–Ω–∏—è –º–µ–Ω—é
        self.menu_states = {
            'main_menu': 'main_menu',
            'interviewing': 'interviewing', 
            'review': 'review'
        }
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î
        self.init_database()
    
    def init_database(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
        try:
            db.insert_default_questions()
            logger.info("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ë–î: {e}")
    
    def get_user_session(self, user_id: int) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å —Å–µ—Å—Å–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        if user_id not in self.user_sessions:
            self.user_sessions[user_id] = {
                'state': 'main_menu',
                'current_question': 1,
                'total_questions': len(db.get_active_questions()),
                'answers': {},
                'started_at': datetime.now()
            }
        return self.user_sessions[user_id]
    
    def update_user_session(self, user_id: int, **kwargs):
        """–û–±–Ω–æ–≤–∏—Ç—å —Å–µ—Å—Å–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        session = self.get_user_session(user_id)
        session.update(kwargs)
        session['last_activity'] = datetime.now()
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–°—Ç–∞—Ä—Ç–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"""
        user = update.effective_user
        user_id = user.id
        
        # –°–±—Ä–æ—Å —Å–µ—Å—Å–∏–∏ –ø—Ä–∏ /start
        self.user_sessions[user_id] = {
            'state': 'main_menu',
            'current_question': 1,
            'total_questions': len(db.get_active_questions()),
            'answers': {},
            'started_at': datetime.now()
        }
        
        await self.show_main_menu(update, context)
    
    async def show_main_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ü–æ–∫–∞–∑–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é (–≠–∫—Ä–∞–Ω 1)"""
        user = update.effective_user
        
        # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å 4 –∫–Ω–æ–ø–∫–∞–º–∏
        keyboard = [
            [InlineKeyboardButton("üìù –ù–∞—á–∞—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ", callback_data="start_interview")],
            [InlineKeyboardButton("üí≥ –û–ø–ª–∞—Ç–∞", callback_data="payment")],
            [InlineKeyboardButton("üìä –°—Ç–∞—Ç—É—Å –∑–∞—è–≤–∫–∏", callback_data="status")],
            [InlineKeyboardButton("‚ÑπÔ∏è –û –ì—Ä–∞–Ω—Ç—Å–µ—Ä–≤–∏—Å–µ", callback_data="about")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        welcome_text = f"""
ü§ñ *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ì—Ä–∞–Ω—Ç–°–µ—Ä–≤–∏—Å!*

–ü—Ä–∏–≤–µ—Ç, {user.first_name}! –Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ —Å–æ–∑–¥–∞—Ç—å –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—É—é –≥—Ä–∞–Ω—Ç–æ–≤—É—é –∑–∞—è–≤–∫—É.

*–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:*
"""
        
        if update.callback_query:
            await update.callback_query.edit_message_text(
                text=welcome_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        else:
            await update.message.reply_text(
                text=welcome_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
    
    async def show_question_navigation(self, update: Update, context: ContextTypes.DEFAULT_TYPE, question_number: int = 1):
        """–ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞–≤–∏–≥–∞—Ü–∏—é –ø–æ –≤–æ–ø—Ä–æ—Å–∞–º (–≠–∫—Ä–∞–Ω 2)"""
        user_id = update.effective_user.id
        session = self.get_user_session(user_id)
        
        # –ü–æ–ª—É—á–∞–µ–º –≤–æ–ø—Ä–æ—Å
        question = db.get_question_by_number(question_number)
        if not question:
            await self.show_error(update, context, "–í–æ–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        self.update_user_session(user_id, 
                               state='interviewing', 
                               current_question=question_number)
        
        # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
        keyboard = []
        
        # –ö–Ω–æ–ø–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
        nav_buttons = []
        if question_number > 1:
            nav_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"prev_question_{question_number-1}"))
        if question_number < session['total_questions']:
            nav_buttons.append(InlineKeyboardButton("–í–ø–µ—Ä—ë–¥ ‚û°Ô∏è", callback_data=f"next_question_{question_number+1}"))
        
        if nav_buttons:
            keyboard.append(nav_buttons)
        
        # –ö–Ω–æ–ø–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –º–µ–Ω—é
        keyboard.append([InlineKeyboardButton("üè† –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é", callback_data="main_menu")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –≤–æ–ø—Ä–æ—Å–∞
        question_text = f"""
*–í–æ–ø—Ä–æ—Å {question_number} –∏–∑ {session['total_questions']}*

{question['question_text']}

{f"üí° *–ü–æ–¥—Å–∫–∞–∑–∫–∞:* {question['hint_text']}" if question.get('hint_text') else ""}

"""
        
        if update.callback_query:
            await update.callback_query.edit_message_text(
                text=question_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        else:
            await update.message.reply_text(
                text=question_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
    
    async def show_review_screen(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ü–æ–∫–∞–∑–∞—Ç—å —ç–∫—Ä–∞–Ω –ø—Ä–æ–≤–µ—Ä–∫–∏ (–≠–∫—Ä–∞–Ω 3)"""
        user_id = update.effective_user.id
        session = self.get_user_session(user_id)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        self.update_user_session(user_id, state='review')
        
        # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
        keyboard = [
            [InlineKeyboardButton("‚úÖ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É", callback_data="submit_for_review")],
            [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"prev_question_{session['current_question']-1}")],
            [InlineKeyboardButton("üè† –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é", callback_data="main_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã
        filled_questions = len([ans for ans in session['answers'].values() if ans])
        completion_percentage = (filled_questions / session['total_questions']) * 100
        
        review_text = f"""
üìã *–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞—è–≤–∫–∏*

*–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è:*
‚Ä¢ –ó–∞–ø–æ–ª–Ω–µ–Ω–æ –≤–æ–ø—Ä–æ—Å–æ–≤: {filled_questions} –∏–∑ {session['total_questions']}
‚Ä¢ –ü—Ä–æ—Ü–µ–Ω—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è: {completion_percentage:.1f}%

*–í–∞–∂–Ω–æ:* –ù–∞–∂–∏–º–∞—è –∫–Ω–æ–ø–∫—É "–û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É" –≤—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ –ø–æ–ª–Ω–æ—Ç—É –∏ –¥–æ—Å—Ç–æ–≤–µ—Ä–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã.

–î–∞–ª–µ–µ –Ω–∞—à —Å–µ—Ä–≤–∏—Å:
‚Ä¢ –°–≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ä–∞–∑–¥–µ–ª—ã –≤–∞—à–µ–π –∑–∞—è–≤–∫–∏
‚Ä¢ –î–∞—Å—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é
‚Ä¢ –ü—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤–µ—Ä–Ω–µ—Ç—Å—è —Å —É—Ç–æ—á–Ω—è—é—â–∏–º–∏ –≤–æ–ø—Ä–æ—Å–∞–º–∏
‚Ä¢ –ì–æ—Ç–æ–≤—ã–π —Ç–µ–∫—Å—Ç –±—É–¥–µ—Ç –≤—ã—Å–ª–∞–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ .pdf

*–ì–æ—Ç–æ–≤—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É?*
"""
        
        if update.callback_query:
            await update.callback_query.edit_message_text(
                text=review_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        else:
            await update.message.reply_text(
                text=review_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
    
    async def handle_menu_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –∫–Ω–æ–ø–æ–∫ –º–µ–Ω—é"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        callback_data = query.data
        
        if callback_data == "start_interview":
            # –ù–∞—á–∏–Ω–∞–µ–º –∏–Ω—Ç–µ—Ä–≤—å—é —Å –ø–µ—Ä–≤–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞
            await self.show_question_navigation(update, context, 1)
            
        elif callback_data == "payment":
            # –ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ —Å–µ—Ä–≤–∏—Å –æ–ø–ª–∞—Ç—ã
            payment_text = """
üí≥ *–û–ø–ª–∞—Ç–∞ —É—Å–ª—É–≥*

–î–ª—è –æ–ø–ª–∞—Ç—ã –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ:
https://grantservice.onff.ru/payment

–ò–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏:
üìû +7 (951) 584-10-83
üìß otinoff@gmail.com
"""
            await query.edit_message_text(
                text=payment_text,
                parse_mode='Markdown'
            )
            
        elif callback_data == "status":
            # –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞—è–≤–∫–∏
            await self.show_application_status(update, context)
            
        elif callback_data == "about":
            # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ—Ä–≤–∏—Å–µ
            about_text = """
‚ÑπÔ∏è *–û –ì—Ä–∞–Ω—Ç—Å–µ—Ä–≤–∏—Å–µ*

*–ì—Ä–∞–Ω—Ç—Å–µ—Ä–≤–∏—Å* - —ç—Ç–æ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∞–Ω—Ç–æ–≤—ã—Ö –∑–∞—è–≤–æ–∫ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ò–ò.

*–ù–∞—à–∏ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:*
‚Ä¢ ü§ñ –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ø—Ä–æ–µ–∫—Ç–æ–≤
‚Ä¢ ‚ö° –ë—ã—Å—Ç—Ä–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –∑–∞—è–≤–æ–∫ (15-20 –º–∏–Ω—É—Ç)
‚Ä¢ üìä –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
‚Ä¢ üí° –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
‚Ä¢ üìÑ –ì–æ—Ç–æ–≤—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã –≤ PDF

*–í–µ–±-—Å–∞–π—Ç:* https://grantservice.onff.ru
*–ü–æ–¥–¥–µ—Ä–∂–∫–∞:* @otinoff_support
"""
            await query.edit_message_text(
                text=about_text,
                parse_mode='Markdown'
            )
            
        elif callback_data == "main_menu":
            # –í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
            await self.show_main_menu(update, context)
            
        elif callback_data.startswith("next_question_"):
            # –ü–µ—Ä–µ—Ö–æ–¥ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –≤–æ–ø—Ä–æ—Å—É
            next_question = int(callback_data.split("_")[-1])
            await self.show_question_navigation(update, context, next_question)
            
        elif callback_data.startswith("prev_question_"):
            # –ü–µ—Ä–µ—Ö–æ–¥ –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É –≤–æ–ø—Ä–æ—Å—É
            prev_question = int(callback_data.split("_")[-1])
            await self.show_question_navigation(update, context, prev_question)
            
        elif callback_data == "submit_for_review":
            # –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É
            await self.submit_application_for_review(update, context)
    
    async def show_application_status(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞—è–≤–∫–∏"""
        user_id = update.effective_user.id
        session = self.get_user_session(user_id)
        
        # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
        filled_questions = len([ans for ans in session['answers'].values() if ans])
        completion_percentage = (filled_questions / session['total_questions']) * 100
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
        if completion_percentage == 0:
            status = "üü° –ù–µ –Ω–∞—á–∞—Ç–æ"
        elif completion_percentage < 100:
            status = "üü† –í —Ä–∞–±–æ—Ç–µ"
        else:
            status = "üü¢ –ó–∞–ø–æ–ª–Ω–µ–Ω–æ"
        
        status_text = f"""
üìä *–°—Ç–∞—Ç—É—Å –∑–∞—è–≤–∫–∏*

*–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å:* {status}
*–ó–∞–ø–æ–ª–Ω–µ–Ω–æ –≤–æ–ø—Ä–æ—Å–æ–≤:* {filled_questions} –∏–∑ {session['total_questions']}
*–ü—Ä–æ—Ü–µ–Ω—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è:* {completion_percentage:.1f}%

*–í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞:* {session['started_at'].strftime('%d.%m.%Y %H:%M')}
*–ü–æ—Å–ª–µ–¥–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:* {session.get('last_activity', session['started_at']).strftime('%d.%m.%Y %H:%M')}
"""
        
        # –ö–Ω–æ–ø–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –º–µ–Ω—é
        keyboard = [[InlineKeyboardButton("üè† –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        query = update.callback_query
        await query.edit_message_text(
            text=status_text,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    async def submit_application_for_review(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É"""
        user_id = update.callback_query.from_user.id
        session = self.get_user_session(user_id)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª–Ω–æ—Ç—É –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è
        filled_questions = len([ans for ans in session['answers'].values() if ans])
        if filled_questions < session['total_questions']:
            await self.show_error(update, context, 
                                f"–ó–∞–ø–æ–ª–Ω–µ–Ω–æ —Ç–æ–ª—å–∫–æ {filled_questions} –∏–∑ {session['total_questions']} –≤–æ–ø—Ä–æ—Å–æ–≤. "
                                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –≤–æ–ø—Ä–æ—Å—ã –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π.")
            return
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ n8n –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        try:
            result = await self.call_n8n_webhook('submit_application', {
                'user_id': user_id,
                'answers': session['answers'],
                'submitted_at': datetime.now().isoformat()
            })
            
            success_text = """
‚úÖ *–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É!*

–í–∞—à–∞ –∑–∞—è–≤–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ –æ–±—Ä–∞–±–æ—Ç–∫—É. 

*–ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –¥–∞–ª—å—à–µ:*
1Ô∏è‚É£ –ù–∞—à –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≤–∞—à–∏ –æ—Ç–≤–µ—Ç—ã
2Ô∏è‚É£ –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∑–∞—è–≤–∫–∏
3Ô∏è‚É£ –°–æ–∑–¥–∞–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é
4Ô∏è‚É£ –ü—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∑–∞–¥–∞—Å—Ç —É—Ç–æ—á–Ω—è—é—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã
5Ô∏è‚É£ –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç –≤ PDF

*–í—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏:* 2-4 —á–∞—Å–∞
*–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:* –í—ã –ø–æ–ª—É—á–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏

–°–ø–∞—Å–∏–±–æ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ì—Ä–∞–Ω—Ç—Å–µ—Ä–≤–∏—Å–∞! üöÄ
"""
            
            keyboard = [[InlineKeyboardButton("üè† –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é", callback_data="main_menu")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.callback_query.edit_message_text(
                text=success_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞—è–≤–∫–∏: {e}")
            await self.show_error(update, context, "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞—è–≤–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
    
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–æ—Ç–≤–µ—Ç—ã –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã)"""
        user_id = update.effective_user.id
        session = self.get_user_session(user_id)
        
        if session['state'] != 'interviewing':
            # –ï—Å–ª–∏ –Ω–µ –≤ —Ä–µ–∂–∏–º–µ –∏–Ω—Ç–µ—Ä–≤—å—é, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
            await self.show_main_menu(update, context)
            return
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç–≤–µ—Ç –Ω–∞ —Ç–µ–∫—É—â–∏–π –≤–æ–ø—Ä–æ—Å
        current_question = session['current_question']
        answer = update.message.text
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞
        question = db.get_question_by_number(current_question)
        if question:
            validation = db.validate_answer(question['id'], answer)
            if not validation['is_valid']:
                await update.message.reply_text(
                    f"‚ùå {validation['error_message']}\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
                )
                return
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç–≤–µ—Ç
        session['answers'][current_question] = answer
        
        # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –≤–æ–ø—Ä–æ—Å—É –∏–ª–∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω –ø—Ä–æ–≤–µ—Ä–∫–∏
        if current_question < session['total_questions']:
            await self.show_question_navigation(update, context, current_question + 1)
        else:
            await self.show_review_screen(update, context)
    
    async def call_n8n_webhook(self, action: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """–í—ã–∑–æ–≤ n8n webhook"""
        try:
            payload = {
                'action': action,
                'data': data,
                'timestamp': datetime.now().isoformat()
            }
            
            response = requests.post(
                self.n8n_webhook_url,
                json=payload,
                headers={'Content-Type': 'application/json'},
                timeout=30
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                logger.error(f"n8n webhook error: {response.status_code}")
                return {'success': False, 'error': f'HTTP {response.status_code}'}
                
        except Exception as e:
            logger.error(f"n8n webhook exception: {e}")
            return {'success': False, 'error': str(e)}
    
    async def show_error(self, update: Update, context: ContextTypes.DEFAULT_TYPE, error_message: str):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ"""
        keyboard = [[InlineKeyboardButton("üè† –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        error_text = f"‚ùå *–û—à–∏–±–∫–∞*\n\n{error_message}"
        
        if update.callback_query:
            await update.callback_query.edit_message_text(
                text=error_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        else:
            await update.message.reply_text(
                text=error_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
    
    def run(self):
        """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        if not self.token:
            logger.error("‚ùå TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            return
        
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
        application = Application.builder().token(self.token).build()
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
        application.add_handler(CommandHandler("start", self.start_command))
        application.add_handler(CallbackQueryHandler(self.handle_menu_callback))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
        logger.info("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω —Å –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–º –º–µ–Ω—é")
        application.run_polling()

if __name__ == "__main__":
    bot = GrantServiceBotWithMenu()
    bot.run() 